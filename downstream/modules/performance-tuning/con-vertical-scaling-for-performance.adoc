// Module file name: con-vertical-scaling-for-performance.adoc
:_mod-docs-content-type: CONCEPT
[id="vertical-scaling-for-performance_{context}"]
= Vertical scaling for performance

[role="_abstract"]
Vertical scaling increases the physical resources available to a service, including the CPU, memory, disk volume, and disk Input/Output Operations per Second (IOPS).
Use vertical scaling for deployments with high resource utilization or workload demand.

== Benefits of vertical scaling

* Relieves resource contention: Applications have access to more resources and this can relieve resource contention or exhaustion.

== Drawbacks and other considerations for vertical scaling

* Extensive testing required: The installer attempts to tune application and system configurations to leverage additional resources, but not all components of the application automatically scale in relation to machine size. 
Manually tuning each variable requires extensive testing. 
For this reason, after an instance size has been verified for an environment, horizontal scaling by adding more instances of the same size is recommended.
* Application-level limitations: For {VMBase} or Containerized deployments, instances with more than 64 CPU cores and 128 GB of RAM might not scale linearly due to system and application-level limits.
* Resource overcommit: Overcommitting virtual machine resources (for example, allocating more virtual CPU/RAM to guests than is physically available on the host) leads to unpredictable performance.
* CPU throttling: In {OCPShort}, setting a CPU `limit` without an equivalent `request` can lead to CPU throttling, even if the node has spare CPU capacity. 
This throttling negatively impacts API latency.
** To mitigate this, always set CPU `requests` equal to CPU `limits`.
** Monitor CPU throttling using the `container_cpu_cfs_throttled_seconds_total` metric.
* Database limitations: Scaling the application increases the maximum potential number of database connections from worker processes and the overall memory, I/O, and CPU utilization of the PostgreSQL instance.
As you scale past the tested deployment models, deploy your separate Postgres instances per component ({Gateway}, {EDAName}, {ControllerName}, {HubName}).