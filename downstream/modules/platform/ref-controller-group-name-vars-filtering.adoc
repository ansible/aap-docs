[id="ref-controller-group-name-vars-filtering"]

= Group name and variables filtering

Two different conditions are demonstrated here to describe the input inventory content:

* The first condition is that the `state` variable defined on the host is set to `shutdown`
* The second condition is that membership in a group with `account_alias` variable set to `product_dev`

The variable `account_alias` demonstrates a group variable. 
In this example, each account has its own group, with group variables giving metadata about those accounts. 
This is common in cloud-source inventories. 
These variables are shown in the general hostvars namespace in Ansible, which is why they have no special treatment in `source_vars`.

The hosts inside the input inventory will fit one condition, the other condition, neither, or both. 
This results in four hosts total for demonstration purposes.

image:inventories-constructed-inventory-venn.png[image]

This folder defines the inventory as an ini type named
`two_conditions.ini`:

....
[account_1234]
host1
host2 state=shutdown

[account_4321]
host3
host4 state=shutdown

[account_1234:vars]
account_alias=product_dev

[account_4321:vars]
account_alias=sustaining
....

The goal here is to return only shutdown hosts that are present in the
group with the `account_alias` variable of `product_dev`. There are two
approaches to this, both shown in yaml format. The first one suggested
is recommended.

[[constr_inv_example]]
[arabic]
. *Construct 2 groups, limit to intersection*

`source_vars`:

....
plugin: constructed
strict: true
groups:
  is_shutdown: state | default("running") == "shutdown"
  product_dev: account_alias == "product_dev"
....

`limit`: `is_shutdown:&product_dev`

This constructed inventory input creates a group for both of the
categories and uses the `limit` (host pattern) to only return hosts that
are in the intersection of those two groups, which is documented in
https://docs.ansible.com/ansible/latest/inventory_guide/intro_patterns.html[host
patterns in Ansible].

Also, when a variable may or may not be defined (depending on the host),
you can give a default, like with `| default("running")` if you know
what value it should have when it is not defined. This helps with
debugging, as described in the `constr_inv_debugging` section.

[arabic, start=2]
. *Construct 1 group, limit to group*

`source_vars`:

....
plugin: constructed
strict: true
groups:
  shutdown_in_product_dev: state | default("running") == "shutdown" and account_alias == "product_dev"
....

`limit`: `shutdown_in_product_dev`

This input creates one group that only includes hosts that match both
criteria. The limit is then just the group name by itself, returning
just *host2*, same as the previous approach.
